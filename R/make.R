#' @title Run your project (build the outdated targets).
#' @description This is the central, most important function
#' of the drake package. It runs all the steps of your
#' workflow in the correct order, skipping any work
#' that is already up to date.
#' See <https://github.com/ropensci/drake/blob/master/README.md#documentation>
#' for an overview of the documentation.
#' @section Interactive mode:
#' In interactive sessions, consider [r_make()], [r_outdated()], etc.
#' rather than [make()], [outdated()], etc. The `r_*()` `drake` functions
#' are more reproducible when the session is interactive.
#'
#' A serious drake workflow should be consistent and reliable,
#' ideally with the help of a master R script.
#' This script should begin in a fresh R session,
#' load your packages and functions in a dependable manner,
#' and then run `make()`. Example:
#' <https://github.com/wlandau/drake-examples/tree/master/gsp>.
#' Batch mode, especially within a container, is particularly helpful.
#'
#' Interactive R sessions are still useful,
#' but they easily grow stale.
#' Targets can falsely invalidate if you accidentally change
#' a function or data object in your environment.
#' So in interactive mode, `make()` now pauses with a menu
#' to protect you from environment-related instability.
#'
#' You can control this menu with the `drake_make_menu` global option.
#' Run `options(drake_make_menu = TRUE)` to show the menu once per session
#' and `options(drake_make_menu = FALSE)` to disable it entirely.
#' You may wish to add a call to `options()` in your local `.Rprofile` file.
#' @section Self-invalidation:
#' It is possible to construct a workflow that tries to invalidate itself.
#' Example:
#' ```r
#' plan <- drake_plan(
#'   x = {
#'     data(mtcars)
#'     mtcars$mpg
#'   },
#'   y = mean(x)
#' )
#' ```
#' Here, because `data()` loads `mtcars` into the global environment,
#' the very act of building `x` changes the dependencies of `x`.
#' In other words, without safeguards, `x` would not be up to date at
#' the end of `make(plan)`.
#' Please try to avoid workflows that modify the global environment.
#' Functions such as `data()` belong in your setup scripts
#' prior to `make()`, not in any functions or commands that get called
#' during `make()` itself.
#'
#' For each target that is still problematic  (e.g.
#' <https://github.com/rstudio/gt/issues/297>)
#' you can safely run the command in its own special `callr::r()` process.
#' Example: <https://github.com/rstudio/gt/issues/297#issuecomment-497778735>. # nolint
#'
#' If that fails, you can run `make(plan, lock_envir = FALSE)`
#' to suppress environment-locking for all targets.
#' However, this is not usually recommended.
#' There are legitimate use cases for `lock_envir = FALSE`
#' (example: <https://ropenscilabs.github.io/drake-manual/hpc.html#parallel-computing-within-targets>) # nolint
#' but most workflows should stick with the default `lock_envir = TRUE`.
#'
#' @seealso
#'   [drake_plan()],
#'   [drake_config()],
#'   [vis_drake_graph()],
#'   [outdated()]
#' @export
#' @return nothing
#' @inheritParams drake_config
#' @param config A list generated by [drake_config()].
#'   If you supply `config` to `make()`, you must not supply any
#'   additional arguments.
#'
#'   [drake_config()] collects and sanitizes the multitude of
#'   parameters and settings that [make()] needs to do its job:
#'   the plan, packages,
#'   the environment of functions and initial data objects,
#'   parallel computing instructions,
#'   verbosity level, etc. Once you generate a list with
#'   [drake_config()], do not modify it by hand.
#'
#'   Utility functions such as [outdated()],
#'   [vis_drake_graph()], and [predict_runtime()]
#'   require output from
#'   [drake_config()] for the `config` argument.
#' @examples
#' \dontrun{
#' isolate_example("Quarantine side effects.", {
#' if (suppressWarnings(require("knitr"))) {
#' load_mtcars_example() # Get the code with drake_example("mtcars").
#' config <- drake_config(my_plan)
#' outdated(config) # Which targets need to be (re)built?
#' make(my_plan) # Build what needs to be built.
#' outdated(config) # Everything is up to date.
#' # Change one of your imported function dependencies.
#' reg2 = function(d) {
#'   d$x3 = d$x^3
#'   lm(y ~ x3, data = d)
#' }
#' outdated(config) # Some targets depend on reg2().
#' make(my_plan) # Rebuild just the outdated targets.
#' outdated(config) # Everything is up to date again.
#' if (requireNamespace("visNetwork", quietly = TRUE)) {
#' vis_drake_graph(config) # See how they fit in an interactive graph.
#' make(my_plan, cache_log_file = TRUE) # Write a CSV log file this time.
#' vis_drake_graph(config) # The colors changed in the graph.
#' # Run targets in parallel:
#' # options(clustermq.scheduler = "multicore") # nolint
#' # make(my_plan, parallelism = "clustermq", jobs = 2) # nolint
#' }
#' clean() # Start from scratch next time around.
#' }
#' })
#' }
make <- function(
  plan,
  targets = NULL,
  envir = parent.frame(),
  verbose = 1L,
  hook = NULL,
  cache = drake::drake_cache(
    verbose = verbose,
    console_log_file = console_log_file
  ),
  fetch_cache = NULL,
  parallelism = "loop",
  jobs = 1L,
  jobs_preprocess = 1L,
  packages = rev(.packages()),
  lib_loc = NULL,
  prework = character(0),
  prepend = NULL,
  command = NULL,
  args = NULL,
  recipe_command = NULL,
  log_progress = TRUE,
  skip_targets = FALSE,
  timeout = NULL,
  cpu = Inf,
  elapsed = Inf,
  retries = 0,
  force = FALSE,
  graph = NULL,
  trigger = drake::trigger(),
  skip_imports = FALSE,
  skip_safety_checks = FALSE,
  config = NULL,
  lazy_load = "eager",
  session_info = TRUE,
  cache_log_file = NULL,
  seed = NULL,
  caching = "master",
  keep_going = FALSE,
  session = NULL,
  pruning_strategy = NULL,
  makefile_path = NULL,
  console_log_file = NULL,
  ensure_workers = NULL,
  garbage_collection = FALSE,
  template = list(),
  sleep = function(i) 0.01,
  hasty_build = NULL,
  memory_strategy = "speed",
  layout = NULL,
  lock_envir = TRUE,
  history = TRUE,
  recover = FALSE,
  recoverable = TRUE
) {
  log_msg(
    "begin make()",
    config = config %||% list(console_log_file = console_log_file)
  )
  check_make_call(match.call())
  force(envir)
  if (is.null(config)) {
    config <- drake_config(
      plan = plan,
      targets = targets,
      envir = envir,
      seed = seed,
      verbose = verbose,
      hook = hook,
      parallelism = parallelism,
      jobs = jobs,
      jobs_preprocess = jobs_preprocess,
      packages = packages,
      lib_loc = lib_loc,
      prework = prework,
      prepend = prepend,
      command = command,
      args = args,
      recipe_command = recipe_command,
      log_progress = log_progress,
      cache = cache,
      fetch_cache = fetch_cache,
      timeout = timeout,
      cpu = cpu,
      elapsed = elapsed,
      retries = retries,
      force = force,
      graph = graph,
      trigger = trigger,
      skip_targets = skip_targets,
      skip_imports = skip_imports,
      skip_safety_checks = skip_safety_checks,
      lazy_load = lazy_load,
      session_info = session_info,
      cache_log_file = cache_log_file,
      caching = caching,
      keep_going = keep_going,
      session = session,
      pruning_strategy = pruning_strategy,
      makefile_path = makefile_path,
      console_log_file = console_log_file,
      ensure_workers = ensure_workers,
      garbage_collection = garbage_collection,
      template = template,
      sleep = sleep,
      hasty_build = hasty_build,
      memory_strategy = memory_strategy,
      layout = layout,
      lock_envir = lock_envir,
      history = history,
      recover = recover,
      recoverable = recoverable
    )
  }
  assert_config_not_plan(config)
  config$running_make <- TRUE
  initialize_session(config = config)
  config$ht_get_hash <- ht_new() # Memoize getting hashes from the cache.
  on.exit(ht_clear(config$ht_get_hash)) # Needs to be empty afterwards.
  if (!config$skip_imports) {
    process_imports(config)
  }
  if (is.character(config$parallelism)) {
    config$graph <- outdated_subgraph(config)
  }
  abort <- FALSE
  if (prompt_intv_make(config)) {
    abort <- abort_intv_make(config) # nocov
  }
  if (abort) {
    return(invisible()) # nocov
  }
  if (!config$skip_targets) {
    process_targets(config)
  }
  conclude_session(config)
  log_msg("end make()", config = config)
  invisible()
}

check_make_call <- function(call) {
  x <- names(call)
  if ("config" %in% names(call) && sum(nzchar(x)) > 1L) {
    warning(
      "if you supply a ", shQuote("config"),
      " argument to ", shQuote("make()"),
      " then all additional arguments are ignored. ",
      "For example, in ", shQuote("make(config = config, verbose = 0L)"),
      "verbosity remains at ", shQuote("config$verbose"), ".",
      call. = FALSE
    )
  }
}

outdated_subgraph <- function(config) {
  outdated <- outdated(config, do_prework = FALSE, make_imports = FALSE)
  log_msg("isolate oudated targets", config = config)
  igraph::induced_subgraph(graph = config$graph, vids = outdated)
}

process_targets <- function(config) {
  if (is.character(config$parallelism)) {
    run_native_backend(config)
  } else {
    run_external_backend(config)
  }
}

run_native_backend <- function(config) {
  parallelism <- match.arg(
    config$parallelism,
    c("loop", "clustermq", "future")
  )
  if (igraph::gorder(config$graph)) {
    get(
      paste0("backend_", parallelism),
      envir = getNamespace("drake")
    )(config)
  } else {
    log_msg(
      "All targets are already up to date.",
      config = config,
      tier = 1L
    )
  }
}

run_external_backend <- function(config) {
  warning(
    "`drake` can indeed accept a custom scheduler function for the ",
    "`parallelism` argument of `make()` ",
    "but this is only for the sake of experimentation ",
    "and graceful deprecation. ",
    "Your own custom schedulers may cause surprising errors. ",
    "Use at your own risk.",
    call. = FALSE
  )
  config$parallelism(config = config)
}

process_imports <- function(config) {
  if (on_windows() && config$jobs_preprocess > 1L) {
    process_imports_parLapply(config) # nocov
  } else {
    process_imports_mclapply(config)
  }
}

#' @title internal function
#' @description only used inside process_imports(). Not a user-side function.
#' @export
#' @keywords internal
#' @param import Character, name of an import to process
#' @param config [drake_config()] object
process_import <- function(import, config) {
  meta <- drake_meta_(import, config)
  if (meta$isfile) {
    value <- NA_character_
    path <- decode_path(import, config)
    is_missing <- !file.exists(path) && !is_url(path)
  } else {
    value <- get_import_from_memory(import, config = config)
    is_missing <- identical(value, NA_character_)
  }
  if (is_missing) {
    log_msg(
      "missing",
      target = display_key(import, config),
      config = config,
      color = "missing"
    )
  } else {
    log_msg("import", target = display_key(import, config), config = config)
  }
  store_single_output(
    target = import,
    value = value,
    meta = meta,
    config = config
  )
}

process_imports_mclapply <- function(config) {
  if (config$jobs_preprocess > 1L) {
    assert_pkg("parallel")
  }
  imports_graph <- subset_graph(config$graph, all_imports(config))
  while (length(V(imports_graph)$name)) {
    imports <- leaf_nodes(imports_graph)
    lightly_parallelize(
      X = imports,
      FUN = drake::process_import,
      config = config,
      jobs = config$jobs_preprocess
    )
    imports_graph <- delete_vertices(imports_graph, v = imports)
  }
  invisible()
}

process_imports_parLapply <- function(config) { # nolint
  assert_pkg("parallel")
  log_msg(
    "load parallel socket cluster with",
    config$jobs_preprocess,
    "workers",
    config = config
  )
  config$cluster <- parallel::makePSOCKcluster(config$jobs_preprocess)
  on.exit(parallel::stopCluster(cl = config$cluster))
  parallel::clusterExport(
    cl = config$cluster, varlist = "config",
    envir = environment())
  if (identical(config$envir, globalenv()) || length(config$debug)) {
    # nocov start
    parallel::clusterExport(
      cl = config$cluster,
      varlist = ls(globalenv(), all.names = TRUE),
      envir = globalenv()
    )
    # nocov end
  }
  parallel::clusterCall(
    cl = config$cluster,
    fun = function() {
      eval(parse(text = "suppressPackageStartupMessages(require(drake))"))
    }
  )
  parallel::clusterCall(
    cl = config$cluster,
    fun = drake::do_prework,
    config = config,
    verbose_packages = FALSE
  )
  imports_graph <- subset_graph(config$graph, all_imports(config))
  while (length(V(imports_graph)$name)) {
    imports <- leaf_nodes(imports_graph)
    parallel::parLapply(
      cl = config$cluster,
      X = imports,
      fun = function(import, config) {
        drake::process_import(import = import, config = config)
      },
      config = config
    )
    imports_graph <- delete_vertices(imports_graph, v = imports)
  }
  invisible()
}

initialize_session <- function(config) {
  runtime_checks(config = config)
  config$cache$set(key = "seed", value = config$seed, namespace = "session")
  init_common_values(config$cache)
  config$eval[[drake_envir_marker]] <- TRUE
  if (config$log_progress) {
    clear_tmp_namespace(
      cache = config$cache,
      jobs = config$jobs_preprocess,
      namespace = "progress"
    )
  }
  drake_set_session_info(cache = config$cache, full = config$session_info)
  do_prework(config = config, verbose_packages = config$verbose)
  invisible()
}

drake_set_session_info <- function(
  path = NULL,
  search = NULL,
  cache = drake::drake_cache(path = path, verbose = verbose),
  verbose = 1L,
  full = TRUE
) {
  if (is.null(cache)) {
    stop("No drake::make() session detected.")
  }
  if (full) {
    cache$set(
      key = "sessionInfo",
      value = utils::sessionInfo(),
      namespace = "session"
    )
  }
  cache$set(
    key = "drake_version",
    value = as.character(utils::packageVersion("drake")),
    namespace = "session"
  )
  invisible()
}

conclude_session <- function(config) {
  drake_cache_log_file_(
    file = config$cache_log_file,
    cache = config$cache,
    jobs = config$jobs_preprocess
  )
  remove(list = names(config$eval), envir = config$eval)
  config$cache$flush_cache()
  if (config$garbage_collection) {
    gc()
  }
  invisible()
}

prompt_intv_make <- function(config) {
  menu_enabled <- .pkg_envir[["drake_make_menu"]] %||%
    getOption("drake_make_menu") %||%
    TRUE
  interactive() &&
    igraph::gorder(config$graph) &&
    menu_enabled
}

abort_intv_make <- function(config) {
  # nocov start
  on.exit(
    assign(
      x = "drake_make_menu",
      value = FALSE,
      envir = .pkg_envir,
      inherits = FALSE
    )
  )
  title <- paste(
    paste(igraph::gorder(config$graph), "outdated targets:"),
    multiline_message(igraph::V(config$graph)$name),
    "\nPlease read the \"Interactive mode\" section of the make() help file.",
    "This prompt only appears once per session.",
    "\nReally run make() instead of r_make() in interactive mode?",
    sep = "\n"
  )
  out <- utils::menu(choices = c("yes", "no"), title = title)
  !identical(as.integer(out), 1L)
  # nocov end
}
